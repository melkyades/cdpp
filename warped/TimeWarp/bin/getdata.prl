#!/local/packages/gnu/bin/perl

# Written by  : Krishnan Subramani
# On          : 31 Jan. 1996
# Purpose     : Extracts data from the .ql file generated by "quantify"
#               1. Takes .ql files as input on the command line.
#               2. Generates output to a file if -o option is specified.
#                   output files generated are <output file>.1, 
#                   <output file>.2 and so on depending on the no. of LPs
#               3. If the -o option is not specified, prints o/p to stdout
#               4. Takes the function names from the file $stringFile
#               5. Generates o/p according to xvgr specs. if -plot option 
#                   is specified in the command line
# Bugs        : 1. Not enough documentation.
#		2. Can not specify a whole class by giving it's class name
#		   alone.

$stringFile = "./Strings";

# Check for command line parameters
$plot = 0;			# Initializing, default no plot
if($#ARGV < 0) {
    die "Usage: getdata.prl -o <output file>  <file1.ql> <file2.ql> ...\n";
} else {
    $counter = 0;
    while($counter <= $#ARGV) {
	$cmdLineOption = $ARGV[$counter];
	if($cmdLineOption eq "-o") {
	    if($outFileName ne "") {
		die "Too many output file names!!!\n";
	    }
	    $outFileName = $ARGV[$counter+1]; # Get Output file name
	    splice(@ARGV,$counter,2); 
	    $counter -= 2;	# Since 2 elements have been removed.
	} elsif($cmdLineOption eq "-plot") {
	    $plot = 1;
	    splice(@ARGV,$counter,1);
	    $counter--;		# Since 1 element has been removed...
	}
	$counter++;
    }
}

# Parse the file Strings and get the class names and the function names.
# Each class name has a string "CLASS_NAME" b4 it in the list.
$classIsNext = 1;

open(STRING_FILE,"< $stringFile") || die "Can not open $stringFile: $!\n";

while($line = <STRING_FILE>) {
    $comment = substr($line,0,1);
    if("\n" eq $line) {
	$classIsNext = 1;
    } elsif('#' ne $comment) {
	chop $line;
	if(1 != $classIsNext) {
	    $class{$line} = $className;
	} elsif(1 == $classIsNext) {
	    $className = $line;
	    $groupData{$className} = 0;
	    $classIsNext = 0;
	}
    }
}

$counter = 0;
$first = 1;
while($counter <= $#ARGV) {
    $inFile = $ARGV[$counter++];
    open(IN_FILE,"<$inFile") || die "\nCan't open $inFile: $!\n\n";
    if($outFileName ne "") {
	if($plot == 1) {
	    $outFile = $outFileName.".$counter";
	    print "Output redirected to File : $outFile\n";
	    if(-e $outFile) {
		print "Output file $outfile exists. Shall I overwrite?(y/n) :";
		read(STDIN,$reponse,2);
		if(chop($response) eq "y") {
		    open(OUT_FILE,">$outFile") || die "\nCan't open output file $outFile: $!\n\n";
		} else {
		    exit;
		}
	    } else {
		open(OUT_FILE,">$outFile") || die "\nCan't open output file $outFile: $!\n\n";
	    }
	} else {
	    $outFile = $outFileName;
	    if((-e $outFile) && ($first == 1)) {
		print "File \"$outFile\" exists.... Overwriting...\n";
		open(OUT_FILE,">$outFile") || die "\nCan't open output file $outFile: $!\n\n";
		$first = 0;
	    }
	    open(OUT_FILE,">>$outFile") || die "\nCan't open output file $outFile: $!\n\n";
	}
    } else {
	open(OUT_FILE,">-");
    }

    $line = <IN_FILE>;		# First line of the file.
    @progName = split(/[ ]+/,$line); # Extrace Program name - $progName[3]
    $line = <IN_FILE>;		# Second line - discard.
    $line = <IN_FILE>;		# Third line
    @scale = split(/[()]+/,$line); # Extrace scale factor - $scale[1]
    $line = <IN_FILE>;		# Fourth line - discard

    while($line = <IN_FILE>) {
	chop $line;
	if($scale[1] eq "% of .root.") {
	    @data = split(/[ %\(]+/,$line);
	    $data = $data[1];
	    $funcName = $data[2];
	} else {
	    @data = split(/[ \(]+/,$line);
	    if($data[0] eq "") {
		$data = $data[1];
		$funcName = $data[2];
	    } else {
		$data = $data[0];
		$funcName = $data[1];
	    }
	}
	
	$groupName = $class{$funcName};
	if($groupName ne "") {
	    $data += $groupData{$groupName};
	    $groupData{$groupName} = $data;
	}
    }
    $tmpData= 0;
    while(($group, $data) = each %groupData) {
	$tmpData += $data;
    }

    $lineCounter = 1;		# Counts the line number
    if($plot == 1) {
	while(($group, $data) = each %groupData) {
	    printf OUT_FILE "%3d %10ld\n", $lineCounter++,$data;
	}
    } else {
	print OUT_FILE "\nLP ",$counter - 1,"\n";
	print OUT_FILE "---------------------------------------------------------\n";
	print OUT_FILE "Group Name                        Cycles       Percentage\n";
	print OUT_FILE "---------------------------------------------------------\n";
	$tmpPercent = 0;
	while(($group, $data) = each %groupData) {
# Beware: Perl hack.  Printing $data, an integer, as a string to avoid
# problems with precision.  %10ld may not be sufficient.
	    printf OUT_FILE "%-30s %10s", $group,$data;
	    if($tmpData != 0) {
		printf OUT_FILE "   %10.5f %%\n",$data * 100.0/$tmpData;
		$tmpPercent += $data * 100.0/$tmpData;
	    } else {
		printf OUT_FILE "   %10.5f %%\n",0;
	    }
	}
	print "Total Percentage = $tmpPercent\n";
# Beware: Perl hack.  Printing $tmpData, an integer, as a string to avoid
# problems with precision.  %10ld may not be sufficient.
	printf OUT_FILE "\n%-25s %15s\n","Total",$tmpData;
    }
    @groups = keys(%groupData);
    foreach $group(@groups) {
	$groupData{$group} = 0;
    }
}
close(OUT_FILE);
close(IN_FILE);
